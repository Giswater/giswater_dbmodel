/*
This file is part of Giswater
The program is free software: you can redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software Foundation, either version 3 of the License,
or (at your option) any later version.
*/

--FUNCTION CODE:2520

DROP FUNCTION IF EXISTS SCHEMA_NAME.gw_fct_utils_csv2pg_import_epanet_rpt(text, text);
DROP FUNCTION IF EXISTS SCHEMA_NAME.gw_fct_utils_csv2pg_import_epanet_rpt(p_data);
CREATE OR REPLACE FUNCTION SCHEMA_NAME.gw_fct_rpt2pg_import_rpt(p_data json)
  RETURNS json AS
$BODY$

/*EXAMPLE
SELECT SCHEMA_NAME.gw_fct_rpt2pg_import_rpt($${"data":{"resultId":"r1"}}$$)

-- fid: 140

*/

DECLARE
v_hour text;
v_type text;
v_rpt record;
v_fid integer = 140;
v_result json;
v_result_info json;
v_result_point json;
v_result_line json;
v_version text;
v_path text;
v_result_id text;
v_qtimestep text;
v_qtolerance text;
v_type_2 text;
v_error_context text;
v_ffactor text;
v_open integer;
v_rec record;
v_time_last integer = 0;

BEGIN

	--  Search path
	SET search_path = "SCHEMA_NAME", public;

	-- get system parameters
	SELECT giswater INTO v_version FROM sys_version ORDER BY id DESC LIMIT 1;

	-- get input data
	v_result_id := ((p_data ->>'data')::json->>'resultId')::text;
	v_path := ((p_data ->>'data')::json->>'path')::text;

	-- Starting process
	INSERT INTO temp_audit_check_data (fid, result_id, error_message) VALUES (140, v_result_id, concat('IMPORT RPT FILE'));
	INSERT INTO temp_audit_check_data (fid, result_id, error_message) VALUES (140, v_result_id, concat('-----------------------------'));

	UPDATE temp_t_csv SET fid = v_fid;

	--remove data from with the same result_id
	FOR v_rpt IN SELECT tablename FROM config_fprocess WHERE fid=v_fid EXCEPT SELECT tablename FROM config_fprocess WHERE tablename='rpt_cat_result' LOOP
		EXECUTE 'DELETE FROM '||v_rpt.tablename||' WHERE result_id='''||v_result_id||''';';
	END LOOP;

	v_hour=null;

	-- clenaning data
	DELETE FROM temp_t_csv WHERE csv1 like '========%';

   	-- This v_open variable is looking for text on csv5 = 'OPEN' wich it means that rpt file have been generated by EPANET UI in spice of EPANET DLL
	v_open = (select count(*) from temp_t_csv where source ='rpt_arc' and csv5 in ('OPEN', 'Open'));

	if v_open > 0 THEN

		DELETE FROM temp_t_csv WHERE csv1 = 'Page';

		-- forcing time values
		for v_rec in select id, csv4 from temp_t_csv where csv2 like 'Results%' order by id desc
		loop
			if v_time_last = 0 then v_time_last = v_rec.id;end if;
			raise notice ' v_rec % v_time_last %', v_rec, v_time_last;
			update temp_t_csv set csv40 = v_rec.csv4 where id > v_rec.id and  id < v_time_last;
			v_time_last := v_rec.id;
		end loop;

		-- nodes
		UPDATE temp_t_csv SET csv6=null WHERE source='rpt_node' AND (csv6='Reservoir' OR csv6='Tank'); -- delete Reservoir AND tank word when quality is not enabled
		DELETE FROM temp_t_csv where csv2 in ('CMH', 'LPS', 'LPM', 'GPM', 'AFD', 'CMD', 'ALD', 'IMGD', 'MGD');
		DELETE FROM temp_t_csv WHERE source='rpt_node' AND (csv1='Node' or csv1='Elevation' or csv1='MINIMUM' or csv1='MAXIMUM' or csv1='DIFFERENTIAL' or csv1='AVERAGE');
		DELETE FROM temp_t_csv WHERE source='rpt_node' AND (csv3='m' or csv5 = 'Hours');

		INSERT INTO rpt_node (node_id, result_id, "time", demand, head, press, quality)
		SELECT csv1, v_result_id, (case when csv40 is null then '00:00' else csv40 end), csv2::numeric, csv3::numeric, csv4::numeric, csv5::numeric
		FROM temp_t_csv WHERE source='rpt_node' AND fid = 140 AND cur_user=current_user ORDER BY id;

		-- arcs
	   	DELETE FROM temp_t_csv WHERE source='rpt_arc' AND (csv1='Link' or csv1='Length' or csv1='Analysis' or csv1='MINIMUM' or csv1='MAXIMUM' or csv1='DIFFERENTIAL' or csv1='AVERAGE');
		INSERT INTO rpt_arc(arc_id,result_id,"time", flow, vel, headloss, other)
		SELECT csv1,v_result_id, (case when csv40 is null then '00:00' else csv40 end), csv2::numeric, csv3::numeric, csv4::numeric, csv5::TEXT
		FROM temp_t_csv WHERE source='rpt_arc' AND fid = 140 AND cur_user=current_user ORDER BY id;

	else
		v_ffactor = (SELECT value FROM config_param_user WHERE parameter = 'inp_report_f_factor' AND cur_user = current_user);

		IF v_ffactor = 'NO' THEN
			UPDATE temp_t_csv SET csv10=csv9, csv9=0 WHERE source='rpt_arc' AND fid = 140 AND cur_user=current_user;
		END IF;

		-- nodes
		UPDATE temp_t_csv SET csv6=null WHERE source='rpt_node' AND (csv6='Reservoir' OR csv6='Tank'); -- delete Reservoir AND tank word when quality is not enabled
		DELETE FROM temp_t_csv WHERE source='rpt_node' AND (csv1='Node' or csv1='Elevation' or csv1='MINIMUM' or csv1='MAXIMUM' or csv1='DIFFERENTIAL' or csv1='AVERAGE');

		INSERT INTO rpt_node (node_id, result_id, "time", top_elev, demand, head, press, quality)
		SELECT csv1, v_result_id, (case when csv40 is null then '00:00' else csv40 end), csv2::numeric, csv3::numeric, csv4::numeric, csv5::numeric, csv6::numeric
		FROM temp_t_csv WHERE source='rpt_node' AND fid = 140 AND cur_user=current_user ORDER BY id;

		--arcs
	   	DELETE FROM temp_t_csv WHERE source='rpt_arc' AND (csv1='Link' or csv1='Length' or csv1='Analysis' or csv1='MINIMUM' or csv1='MAXIMUM' or csv1='DIFFERENTIAL' or csv1='AVERAGE');
		INSERT INTO rpt_arc(arc_id,result_id,"time",length, diameter, flow, vel, headloss,setting,reaction, ffactor,other)
		SELECT csv1,v_result_id, (case when csv40 is null then '00:00' else csv40 end), csv2::numeric, csv3::numeric, csv4::numeric, csv5::numeric, csv6::numeric, csv7::numeric, csv8::numeric, csv9::numeric, csv10
		FROM temp_t_csv WHERE source='rpt_arc' AND fid = 140 AND cur_user=current_user ORDER BY id;

	end if;

	-- energy_usage
	INSERT INTO rpt_energy_usage(result_id, nodarc_id, usage_fact, avg_effic, kwhr_mgal, avg_kw, peak_kw, cost_day)
	SELECT v_result_id, csv1, csv2::numeric, csv3::numeric, csv4::numeric, csv5::numeric, csv6::numeric, csv7::numeric
	FROM temp_t_csv WHERE source='rpt_energy_usage' AND fid = 140 AND cur_user=current_user AND csv1 NOT IN ('Energy', 'Pump', 'Demand', 'Total') ORDER BY id;

	-- hydraulic_status
	INSERT INTO rpt_hydraulic_status (result_id, time, text)
	SELECT v_result_id, csv1, concat (csv2, ' ', csv3,' ', csv4, ' ',csv5, ' ',csv6, ' ',csv7, ' ',csv8, ' ',csv9, ' ',csv10, ' ',csv11,' ', csv12,' ', csv13, ' ',
	csv14, ' ',csv15, ' ',csv16, ' ',csv17, ' ',csv18)
	FROM temp_t_csv WHERE source='rpt_hydraulic_status' AND fid = 140 AND cur_user=current_user AND csv1 = 'WARNING' ORDER BY id;

	INSERT INTO rpt_hydraulic_status (result_id, time, text)
	SELECT v_result_id, csv1, concat (csv2, ' ', csv3,' ', csv4, ' ',csv5, ' ',csv6, ' ',csv7, ' ',csv8, ' ',csv9, ' ',csv10, ' ',csv11,' ', csv12,' ', csv13, ' ',
	csv14, ' ',csv15, ' ',csv16, ' ',csv17, ' ',csv18)
	FROM temp_t_csv WHERE source='rpt_hydraulic_status' AND fid = 140 AND cur_user=current_user ORDER BY id;

	-- rpt_cat_result
	-- to do:
	--v_qtimestep text;
	--v_qtolerance text;

	UPDATE rpt_cat_result set q_timestep=v_qtimestep, q_tolerance=v_qtolerance
				, expl_id = (SELECT array_agg(expl_id) FROM selector_expl WHERE cur_user = current_user AND expl_id > 0)
				, sector_id = (SELECT array_agg(sector_id) FROM selector_sector WHERE cur_user = current_user AND sector_id > 0)
				WHERE result_id = v_result_id;

	INSERT INTO temp_audit_check_data (fid, error_message) VALUES (140, 'Rpt file import process -> Finished. Check your data');

	-- get results
	-- info
	SELECT array_to_json(array_agg(row_to_json(row))) INTO v_result
	FROM (SELECT error_message as message FROM temp_audit_check_data WHERE cur_user="current_user"() AND fid = 140  order by id) row;
	v_result := COALESCE(v_result, '{}');
	v_result_info = concat ('{"values":',v_result, '}');

	--Control nulls
	v_version := COALESCE(v_version, '{}');
	v_result_info := COALESCE(v_result_info, '{}');
	v_result_point := COALESCE(v_result_point, '{}');
	v_result_line := COALESCE(v_result_line, '{}');

	-- Return
	RETURN ('{"status":"Accepted", "message":{"level":1, "text":"Import succesfully"}, "version":"'||v_version||'"'||
             ',"body":{"form":{}'||
		     ',"data":{ "info":'||v_result_info||','||
				'"point":'||v_result_point||','||
				'"line":'||v_result_line||
		       '}}'||
	    '}')::json;

END;
$BODY$
LANGUAGE plpgsql VOLATILE
COST 100;
