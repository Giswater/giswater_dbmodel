/*
This file is part of Giswater
The program is free software: you can redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software Foundation, either version 3 of the License,
or (at your option) any later version.
*/

-- FUNCTION CODE: 3402

DROP FUNCTION IF EXISTS SCHEMA_NAME.gw_fct_graphanalytics_manage_temporary(json);
CREATE OR REPLACE FUNCTION SCHEMA_NAME.gw_fct_graphanalytics_manage_temporary(p_data json)
RETURNS json AS
$BODY$

/*
SELECT gw_fct_graphanalytics_manage_temporary('{"data":{"action": "CREATE", "fct_name":"MINSECTOR", "usePsector": "true", "expl_id": "1"}}');
SELECT gw_fct_graphanalytics_manage_temporary('{"data":{"action": "CREATE", "fct_name":"MINSECTOR", "usePsector": "false", "expl_id": "1, 2, 3, 4"}}');
SELECT gw_fct_graphanalytics_manage_temporary('{"data":{"action": "DROP", "fct_name":"MINSECTOR"}}');
*/

DECLARE

    -- configuration
    v_project_type TEXT;
    v_version TEXT;

    -- parameters
    v_fct_name TEXT;
    v_fct_type TEXT;
    v_action TEXT;
    v_use_psector TEXT;
    v_netscenario TEXT;

    -- extra variables
    v_return_message TEXT;
    v_mapzone_field text;

    -- CHECKS
    v_arc_list TEXT;

BEGIN

	-- Search path
    SET search_path = "SCHEMA_NAME", public;

    -- Select configuration values
    SELECT giswater, project_type INTO v_version, v_project_type FROM sys_version ORDER BY id DESC LIMIT 1;

	-- Get variables from input JSON
    v_fct_name = (SELECT (p_data::json->>'data')::json->>'fct_name');
    v_fct_type = (SELECT (p_data::json->>'data')::json->>'fct_type');
    v_action = (SELECT (p_data::json->>'data')::json->>'action');
    v_use_psector = (SELECT (p_data::json->>'data')::json->>'use_psector');
    v_netscenario = (SELECT (p_data::json->>'data')::json->>'netscenario');

    IF v_action = 'CREATE' THEN
        -- Create temporary tables

        v_mapzone_field :=
        CASE
            WHEN v_fct_name LIKE '%TYPE'
                THEN lower(v_fct_name)

            WHEN v_fct_name = 'MINCUT'
                THEN 'minsector_id'

            WHEN v_fct_name = 'MINSECTOR'
                THEN 'minsector_id'

            WHEN v_fct_name = 'OMUNIT'
                THEN 'omunit_id'

            WHEN v_fct_type = 'MAPZONE'
                THEN lower(v_fct_name) || '_id'

            ELSE NULL
        END;

        IF v_mapzone_field IS NULL THEN
            RAISE EXCEPTION
                'Cannot determine mapzone field for v_fct_name = %',
                v_fct_name;
        END IF;

        CREATE TEMP TABLE IF NOT EXISTS temp_pgr_old_mapzone (
            mapzone_id INTEGER,
            CONSTRAINT temp_pgr_old_mapzone_pkey PRIMARY KEY (mapzone_id)
        );

        CREATE TEMP TABLE IF NOT EXISTS temp_pgr_node (
            pgr_node_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
            mapzone_id INTEGER DEFAULT 0,
            graph_delimiter VARCHAR(30) DEFAULT 'NONE',
            CONSTRAINT temp_pgr_node_pkey PRIMARY KEY (pgr_node_id)
        );
        CREATE INDEX IF NOT EXISTS temp_pgr_node_mapzone_id_idx ON temp_pgr_node USING btree (mapzone_id);

        CREATE TEMP TABLE IF NOT EXISTS temp_pgr_arc (
            pgr_arc_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
            pgr_node_1 INTEGER,
            pgr_node_2 INTEGER,
            mapzone_id INTEGER DEFAULT 0,
            graph_delimiter VARCHAR(30) DEFAULT 'NONE',
            CONSTRAINT temp_pgr_arc_pkey PRIMARY KEY (pgr_arc_id)
        );
        CREATE INDEX IF NOT EXISTS temp_pgr_arc_pgr_node1_idx ON temp_pgr_arc USING btree (pgr_node_1);
        CREATE INDEX IF NOT EXISTS temp_pgr_arc_pgr_node2_idx ON temp_pgr_arc USING btree (pgr_node_2);
        CREATE INDEX IF NOT EXISTS temp_pgr_arc_mapzone_id_idx ON temp_pgr_arc USING btree (mapzone_id);

        CREATE TEMP TABLE IF NOT EXISTS temp_pgr_connec (
            pgr_connec_id INTEGER NOT NULL,
            pgr_arc_id INTEGER NOT NULL,
            mapzone_id INTEGER DEFAULT 0,
            graph_delimiter VARCHAR(30) DEFAULT 'NONE',
            CONSTRAINT temp_pgr_connec_pkey PRIMARY KEY (pgr_connec_id)
        );
        CREATE INDEX IF NOT EXISTS temp_pgr_connec_pgr_arc_id_idx ON temp_pgr_connec USING btree (pgr_arc_id);
        CREATE INDEX IF NOT EXISTS temp_pgr_connec_mapzone_id_idx ON temp_pgr_connec USING btree (mapzone_id);

        IF v_project_type = 'UD' THEN
            CREATE TEMP TABLE IF NOT EXISTS temp_pgr_gully (
                pgr_gully_id INTEGER NOT NULL,
                pgr_arc_id INTEGER NOT NULL,
                mapzone_id INTEGER DEFAULT 0,
                graph_delimiter VARCHAR(30) DEFAULT 'NONE',
                CONSTRAINT temp_pgr_gully_pkey PRIMARY KEY (pgr_gully_id)
            );
            CREATE INDEX IF NOT EXISTS temp_pgr_gully_pgr_arc_id_idx ON temp_pgr_gully USING btree (pgr_arc_id);
            CREATE INDEX IF NOT EXISTS temp_pgr_gully_mapzone_id_idx ON temp_pgr_gully USING btree (mapzone_id);
        END IF;

        CREATE TEMP TABLE IF NOT EXISTS temp_pgr_arc_linegraph (
            pgr_arc_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
            pgr_node_id INTEGER NULL,
            pgr_node_1 INTEGER NULL,
            pgr_node_2 INTEGER NULL,
            mapzone_id INTEGER DEFAULT 0,
            graph_delimiter VARCHAR(30) DEFAULT 'NONE',
            "cost" FLOAT NOT NULL DEFAULT 1,
            reverse_cost FLOAT NOT NULL DEFAULT 1,
            to_arc INTEGER,
            CONSTRAINT temp_pgr_arc_linegraph_pkey PRIMARY KEY (pgr_arc_id)
        );
        CREATE INDEX IF NOT EXISTS temp_pgr_arc_linegraph_pgr_node_1_idx ON temp_pgr_arc_linegraph USING btree (pgr_node_1);
        CREATE INDEX IF NOT EXISTS temp_pgr_arc_linegraph_pgr_node_2_idx ON temp_pgr_arc_linegraph USING btree (pgr_node_2);
        CREATE INDEX IF NOT EXISTS temp_pgr_arc_linegraph_pgr_node_id_idx ON temp_pgr_arc_linegraph USING btree (pgr_node_id);
        CREATE INDEX IF NOT EXISTS temp_pgr_arc_linegraph_mapzone_id_idx ON temp_pgr_arc_linegraph USING btree (mapzone_id);


        CREATE TEMP TABLE IF NOT EXISTS temp_pgr_drivingdistance (
                seq INTEGER NOT NULL,
                "depth" INTEGER NULL,
                start_vid INTEGER NULL,
                pred INTEGER NULL,
                node INTEGER NULL,
                edge INTEGER NULL,
                "cost" FLOAT NULL,
                agg_cost FLOAT NULL,
                CONSTRAINT temp_pgr_drivingdistance_pkey PRIMARY KEY (seq)
            );
        CREATE INDEX IF NOT EXISTS temp_pgr_drivingdistance_start_vid_idx ON temp_pgr_drivingdistance USING btree (start_vid);
        CREATE INDEX IF NOT EXISTS temp_pgr_drivingdistance_node_idx ON temp_pgr_drivingdistance USING btree (node);
        CREATE INDEX IF NOT EXISTS temp_pgr_drivingdistance_edge_idx ON temp_pgr_drivingdistance USING btree (edge);

        -- Create other additional temporary tables
        CREATE TEMP TABLE IF NOT EXISTS temp_audit_check_data (LIKE SCHEMA_NAME.audit_check_data INCLUDING ALL);

        CREATE TEMP TABLE IF NOT EXISTS temp_pgr_connectedcomponents (
            seq INTEGER NOT NULL,
            component INTEGER NULL,
            node INTEGER NULL,
            CONSTRAINT temp_pgr_connectedcomponents_pkey PRIMARY KEY (seq)
        );
        CREATE INDEX IF NOT EXISTS temp_pgr_connectedcomponents_component_idx ON temp_pgr_connectedcomponents USING btree (component);
        CREATE INDEX IF NOT EXISTS temp_pgr_connectedcomponents_node_idx ON temp_pgr_connectedcomponents USING btree (node);
        
        -- Create temporary tables depending on the project type
        IF v_fct_type = 'MAPZONE' THEN

            CREATE TEMP TABLE IF NOT EXISTS temp_pgr_graphconfig (
                id INTEGER GENERATED BY DEFAULT AS IDENTITY,
                mapzone_id INTEGER,
                graph_type VARCHAR(30), -- use, forceClosed, ignore
                pgr_node_id INTEGER,
                pgr_arc_id INTEGER,
                CONSTRAINT temp_pgr_graphconfig_pkey PRIMARY KEY (id)
            );
            CREATE INDEX IF NOT EXISTS idx_temp_pgr_graphconfig_mapzone_id ON temp_pgr_graphconfig USING btree (mapzone_id);
            CREATE INDEX IF NOT EXISTS idx_temp_pgr_graphconfig_pgr_node_id ON temp_pgr_graphconfig USING btree (pgr_node_id);
            CREATE INDEX IF NOT EXISTS idx_temp_pgr_graphconfig_pgr_arc_id ON temp_pgr_graphconfig USING btree (pgr_arc_id);

			CREATE TEMP TABLE IF NOT EXISTS temp_pgr_mapzone_graph (
				id INTEGER GENERATED BY DEFAULT AS IDENTITY,
				start_vid int4 NOT NULL, 
				end_vid int4 NOT NULL,
				mapzone_id int4 NOT NULL,
				node_1 int4 NOT NULL,
				node_type_1 varchar(30) NULL,
				node_2 int4 NOT NULL,
				node_type_2 varchar(30) NULL,
				the_geom geometry(MultiLineString, SRID_VALUE),
				CONSTRAINT temp_pgr_mapzone_graph_pkey PRIMARY KEY (id)
			);
			CREATE INDEX IF NOT EXISTS temp_pgr_mapzone_graph_start_vid_idx ON temp_pgr_mapzone_graph USING btree (start_vid);
			CREATE INDEX IF NOT EXISTS temp_pgr_mapzone_graph_end_vid_idx ON temp_pgr_mapzone_graph USING btree (end_vid);
			CREATE INDEX IF NOT EXISTS temp_pgr_mapzone_graph_node_1_idx ON temp_pgr_mapzone_graph USING btree (node_1);
			CREATE INDEX IF NOT EXISTS temp_pgr_mapzone_graph_node_2_idx ON temp_pgr_mapzone_graph USING btree (node_2);
			CREATE INDEX IF NOT EXISTS temp_pgr_mapzone_graph_mapzone_id_idx ON temp_pgr_mapzone_graph USING btree (mapzone_id);

			CREATE TEMP TABLE IF NOT EXISTS temp_pgr_dijkstra (
                seq INTEGER NOT NULL,
                path_seq INTEGER NULL,
                start_vid INTEGER NULL,
				end_vid INTEGER NULL,
                node INTEGER NULL,
                edge INTEGER NULL,
                "cost" FLOAT NULL,
                agg_cost FLOAT NULL,
                CONSTRAINT temp_pgr_dijkstra_pkey PRIMARY KEY (seq)
            );
			CREATE INDEX IF NOT EXISTS temp_pgr_dijkstra_start_vid_idx ON temp_pgr_dijkstra USING btree (start_vid);
			CREATE INDEX IF NOT EXISTS temp_pgr_dijkstra_end_vid_idx ON temp_pgr_dijkstra USING btree (end_vid);
			CREATE INDEX IF NOT EXISTS temp_pgr_dijkstra_node_idx ON temp_pgr_dijkstra USING btree (node);
			CREATE INDEX IF NOT EXISTS temp_pgr_dijkstra_edge_idx ON temp_pgr_dijkstra USING btree (edge);
            
            EXECUTE format(
                'CREATE TEMP TABLE IF NOT EXISTS temp_pgr_mapzone (LIKE %I.%I INCLUDING ALL)',
                'SCHEMA_NAME',
                lower(v_fct_name)
            );

            EXECUTE format(
                'ALTER TABLE temp_pgr_mapzone DROP COLUMN IF EXISTS %I',
                lower(v_fct_name) || '_id'
            );

            ALTER TABLE temp_pgr_mapzone ADD COLUMN IF NOT EXISTS component INTEGER NOT NULL;
            CREATE INDEX IF NOT EXISTS temp_pgr_mapzone_component_idx ON temp_pgr_mapzone USING btree (component);
            ALTER TABLE temp_pgr_mapzone ADD COLUMN IF NOT EXISTS mapzone_ids INTEGER[];
            ALTER TABLE temp_pgr_mapzone ADD COLUMN IF NOT EXISTS mapzone_id INTEGER DEFAULT 0;
            CREATE INDEX IF NOT EXISTS temp_pgr_mapzone_mapzone_id_idx ON temp_pgr_mapzone USING btree (mapzone_id);
            

            ALTER TABLE temp_pgr_node ADD COLUMN IF NOT EXISTS component INTEGER DEFAULT 0;
            CREATE INDEX IF NOT EXISTS temp_pgr_node_component_idx ON temp_pgr_node USING btree (component);

            ALTER TABLE temp_pgr_arc ADD COLUMN IF NOT EXISTS node_parent INTEGER;
            CREATE INDEX IF NOT EXISTS temp_pgr_arc_node_parent_idx ON temp_pgr_arc USING btree (node_parent);

            ALTER TABLE temp_pgr_arc ADD COLUMN IF NOT EXISTS component INTEGER DEFAULT 0;
            CREATE INDEX IF NOT EXISTS temp_pgr_arc_component_idx ON temp_pgr_arc USING btree (component);

            ALTER TABLE temp_pgr_connec ADD COLUMN IF NOT EXISTS component INTEGER DEFAULT 0;
            CREATE INDEX IF NOT EXISTS temp_pgr_connec_component_idx ON temp_pgr_connec USING btree (component);
            
            IF v_project_type = 'UD' THEN
                ALTER TABLE temp_pgr_gully ADD COLUMN IF NOT EXISTS component INTEGER DEFAULT 0;
                CREATE INDEX IF NOT EXISTS temp_pgr_gully_component_idx ON temp_pgr_gully USING btree (component);
            END IF;

        END IF;

        IF v_fct_name = 'DMA' THEN
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_om_waterbalance_dma_graph (LIKE SCHEMA_NAME.om_waterbalance_dma_graph INCLUDING ALL);
        END IF;

        IF v_project_type = 'WS' THEN

            ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS closed BOOL;
            ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS broken BOOL;

            -- for specific functions

            IF v_fct_name IN ('MINCUT', 'MINSECTOR') THEN  
                
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_node_minsector (LIKE temp_pgr_node INCLUDING ALL);

                ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS adjacent_mincut_id INTEGER DEFAULT 0;
                ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS unaccess BOOL DEFAULT FALSE; -- if TRUE, it means the valve is not accessible
                ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS proposed BOOL DEFAULT FALSE;
                ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS changestatus BOOL DEFAULT FALSE;
                ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS cost_mincut FLOAT NOT NULL DEFAULT 1;
                ALTER TABLE temp_pgr_arc_linegraph ADD COLUMN IF NOT EXISTS reverse_cost_mincut FLOAT NOT NULL DEFAULT 1;
            END IF;

            IF v_fct_name = 'MINSECTOR' THEN
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_minsector_graph (LIKE SCHEMA_NAME.minsector_graph INCLUDING ALL);
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_minsector (LIKE SCHEMA_NAME.minsector INCLUDING ALL);
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_minsector_mincut (LIKE SCHEMA_NAME.minsector_mincut INCLUDING ALL);
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_minsector_mincut_valve (LIKE SCHEMA_NAME.minsector_mincut_valve INCLUDING ALL);
            END IF;

        ELSE 
            IF v_fct_name = 'DWFZONE' THEN
               
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_drivingdistance_initoverflowpath (
                    seq INTEGER NOT NULL,
                    "depth" INTEGER NULL,
                    start_vid INTEGER NULL,
                    pred INTEGER NULL,
                    node INTEGER NULL,
                    edge INTEGER NULL,
                    "cost" FLOAT NULL,
                    agg_cost FLOAT NULL,
                    CONSTRAINT temp_pgr_drivingdistance_initoverflowpath_pkey PRIMARY KEY (seq)
                );
                CREATE INDEX IF NOT EXISTS temp_pgr_drivingdistance_initoverflowpath_start_vid_idx ON temp_pgr_drivingdistance_initoverflowpath USING btree (start_vid);
                CREATE INDEX IF NOT EXISTS temp_pgr_drivingdistance_initoverflowpath_node_idx ON temp_pgr_drivingdistance_initoverflowpath USING btree (node);
                CREATE INDEX IF NOT EXISTS temp_pgr_drivingdistance_initoverflowpath_edge_idx ON temp_pgr_drivingdistance_initoverflowpath USING btree (edge);
            END IF;

            IF v_fct_name = 'OMUNIT' THEN
                ALTER TABLE temp_pgr_arc ADD COLUMN  IF NOT EXISTS macromapzone_id INTEGER DEFAULT 0;
                CREATE INDEX IF NOT EXISTS temp_pgr_arc_macromapzone_id_idx ON temp_pgr_arc USING btree ("macromapzone_id");
                
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_omunit (LIKE SCHEMA_NAME.omunit INCLUDING ALL);
                CREATE TEMP TABLE IF NOT EXISTS temp_pgr_macroomunit (LIKE SCHEMA_NAME.macroomunit INCLUDING ALL);

            END IF;
        END IF;

        -- Create temporary views
        IF v_use_psector = 'true' THEN
            -- with psectors

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_arc AS
                SELECT
                    a.arc_id,
                    a.node_1,
                    a.node_2,
                    a.expl_id,
                    a.%I,
                    a.the_geom
                FROM arc a
                LEFT JOIN LATERAL (
                    SELECT pp_1.state
                    FROM plan_psector_x_arc pp_1
                    WHERE pp_1.arc_id = a.arc_id
                    AND pp_1.psector_id IN (
                        SELECT sp.psector_id
                        FROM selector_psector sp
                        WHERE sp.cur_user = CURRENT_USER
                    )
                    ORDER BY pp_1.psector_id DESC
                    LIMIT 1
                ) pp ON TRUE
                JOIN value_state_type vst ON vst.id = a.state_type
                JOIN exploitation e ON e.expl_id = a.expl_id
                WHERE COALESCE(pp.state, a.state) = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE
                AND a.node_1 IS NOT NULL
                AND a.node_2 IS NOT NULL;
            $sql$, v_mapzone_field);

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_node AS
                SELECT
                    n.node_id,
                    cn.node_type,
                    cf.graph_delimiter,
                    n.expl_id,
                    n.%I,
                    n.the_geom
                FROM node n
                LEFT JOIN LATERAL (
                    SELECT pp_1.state
                    FROM plan_psector_x_node pp_1
                    WHERE pp_1.node_id = n.node_id
                    AND pp_1.psector_id IN (
                        SELECT sp.psector_id
                        FROM selector_psector sp
                        WHERE sp.cur_user = CURRENT_USER
                    )
                    ORDER BY pp_1.psector_id DESC
                    LIMIT 1
                ) pp ON TRUE
                JOIN cat_node cn ON cn.id = n.nodecat_id
                JOIN cat_feature_node cf ON cf.id = cn.node_type
                JOIN value_state_type vst ON vst.id = n.state_type
                JOIN exploitation e ON e.expl_id = n.expl_id
                WHERE COALESCE(pp.state, n.state) = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE;
            $sql$, v_mapzone_field);

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_connec AS
                SELECT
                    c.connec_id,
                    COALESCE(pp.arc_id, c.arc_id) AS arc_id,
                    c.customer_code,
                    c.expl_id,
                    c.%I,
                    c.the_geom
                FROM connec c
                LEFT JOIN LATERAL (
                    SELECT pp_1.state, pp_1.arc_id
                    FROM plan_psector_x_connec pp_1
                    WHERE pp_1.connec_id = c.connec_id
                    AND pp_1.psector_id IN (
                        SELECT sp.psector_id
                        FROM selector_psector sp
                        WHERE sp.cur_user = CURRENT_USER
                    )
                    ORDER BY pp_1.psector_id DESC, pp_1.state DESC
                    LIMIT 1
                ) pp ON TRUE
                JOIN value_state_type vst ON vst.id = c.state_type
                JOIN exploitation e ON e.expl_id = c.expl_id
                WHERE COALESCE(pp.state, c.state) = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE;
            $sql$, v_mapzone_field);

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_link_connec AS
                SELECT
                    l.link_id,
                    COALESCE(pp.arc_id, c.arc_id) AS arc_id,
                    l.feature_id,
                    l.feature_type,
                    l.expl_id,
                    l.%I,
                    l.the_geom
                FROM link l
                JOIN connec c ON l.feature_id = c.connec_id
                LEFT JOIN LATERAL (
                    SELECT pp1.connec_id, pp1.psector_id
                    FROM plan_psector_x_connec pp1
                    WHERE pp1.connec_id = l.feature_id
                    AND pp1.psector_id IN (
                        SELECT sp.psector_id
                        FROM selector_psector sp
                        WHERE sp.cur_user = CURRENT_USER
                    )
                    ORDER BY pp1.psector_id DESC
                    LIMIT 1
                ) last_ps ON TRUE
                LEFT JOIN LATERAL (
                    SELECT pp2.state, pp2.arc_id
                    FROM plan_psector_x_connec pp2
                    WHERE pp2.link_id = l.link_id
                    AND pp2.psector_id = last_ps.psector_id
                    LIMIT 1
                ) pp ON TRUE
                JOIN value_state_type vst ON vst.id = l.state_type
                JOIN exploitation e ON e.expl_id = l.expl_id
                WHERE COALESCE(pp.state, l.state) = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE
                AND l.feature_type = 'CONNEC';
            $sql$, v_mapzone_field);

            IF v_project_type = 'UD' THEN

                EXECUTE format($sql$
                    CREATE OR REPLACE TEMPORARY VIEW v_temp_gully AS
                    SELECT
                        g.gully_id,
                        COALESCE(pp.arc_id, g.arc_id) AS arc_id,
                        g.expl_id,
                        g.%I,
                        g.the_geom
                    FROM gully g
                    LEFT JOIN LATERAL (
                        SELECT pp_1.state, pp_1.arc_id
                        FROM plan_psector_x_gully pp_1
                        WHERE pp_1.gully_id = g.gully_id
                        AND pp_1.psector_id IN (
                            SELECT sp.psector_id
                            FROM selector_psector sp
                            WHERE sp.cur_user = CURRENT_USER
                        )
                        ORDER BY pp_1.psector_id DESC, pp_1.state DESC
                        LIMIT 1
                    ) pp ON TRUE
                    JOIN value_state_type vst ON vst.id = g.state_type
                    JOIN exploitation e ON e.expl_id = g.expl_id
                    WHERE COALESCE(pp.state, g.state) = 1
                    AND vst.is_operative = TRUE
                    AND e.active = TRUE;
                $sql$, v_mapzone_field);

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_link_gully AS
                SELECT
                    l.link_id,
                    COALESCE(pp.arc_id, g.arc_id) AS arc_id,
                    l.feature_id,
                    l.feature_type,
                    l.expl_id,
                    l.%I,
                    l.the_geom
                FROM link l
                JOIN gully g ON l.feature_id = g.gully_id
                LEFT JOIN LATERAL (
                    SELECT pp1.gully_id, pp1.psector_id
                    FROM plan_psector_x_gully pp1
                    WHERE pp1.gully_id = l.feature_id
                    AND pp1.psector_id IN (
                        SELECT sp.psector_id
                        FROM selector_psector sp
                        WHERE sp.cur_user = CURRENT_USER
                    )
                    ORDER BY pp1.psector_id DESC
                    LIMIT 1
                ) last_ps ON TRUE
                LEFT JOIN LATERAL (
                    SELECT pp2.state, pp2.arc_id
                    FROM plan_psector_x_gully pp2
                    WHERE pp2.link_id = l.link_id
                    AND pp2.psector_id = last_ps.psector_id
                    LIMIT 1
                ) pp ON TRUE
                JOIN value_state_type vst ON vst.id = l.state_type
                JOIN exploitation e ON e.expl_id = l.expl_id
                WHERE COALESCE(pp.state, l.state) = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE
                AND l.feature_type = 'GULLY';
            $sql$, v_mapzone_field);

            END IF;

        ELSE
            -- without psectors

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_arc AS
                SELECT
                    a.arc_id,
                    a.node_1,
                    a.node_2,
                    a.expl_id,
                    a.%I,
                    a.the_geom
                FROM arc a
                JOIN value_state_type vst ON vst.id = a.state_type
                JOIN exploitation e ON e.expl_id = a.expl_id
                WHERE a.state = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE
                AND a.node_1 IS NOT NULL
                AND a.node_2 IS NOT NULL;
            $sql$, v_mapzone_field);

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_node AS
                SELECT
                    n.node_id,
                    cn.node_type,
                    cf.graph_delimiter,
                    n.expl_id,
                    n.%I,
                    n.the_geom
                FROM node n
                JOIN value_state_type vst ON vst.id = n.state_type
                JOIN exploitation e ON e.expl_id = n.expl_id
                JOIN cat_node cn ON cn.id = n.nodecat_id
                JOIN cat_feature_node cf ON cf.id = cn.node_type
                WHERE n.state = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE;
            $sql$, v_mapzone_field);

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_connec AS
                SELECT
                    c.connec_id,
                    c.arc_id,
                    c.customer_code,
                    c.expl_id,
                    c.%I,
                    c.the_geom
                FROM connec c
                JOIN value_state_type vst ON vst.id = c.state_type
                JOIN exploitation e ON e.expl_id = c.expl_id
                WHERE c.state = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE;
            $sql$, v_mapzone_field);

            EXECUTE format($sql$
                CREATE OR REPLACE TEMPORARY VIEW v_temp_link_connec AS
                SELECT
                    l.link_id,
                    c.arc_id,
                    l.feature_id,
                    l.feature_type,
                    l.expl_id,
                    l.%I,
                    l.the_geom
                FROM link l
                JOIN connec c ON l.feature_id = c.connec_id
                JOIN value_state_type vst ON vst.id = l.state_type
                JOIN exploitation e ON e.expl_id = l.expl_id
                WHERE l.state = 1
                AND vst.is_operative = TRUE
                AND e.active = TRUE
                AND l.feature_type = 'CONNEC';
            $sql$, v_mapzone_field);

            IF v_project_type = 'UD' THEN

                EXECUTE format($sql$
                    CREATE OR REPLACE TEMPORARY VIEW v_temp_gully AS
                    SELECT
                        g.gully_id,
                        g.arc_id,
                        g.expl_id,
                        g.%I,
                        g.the_geom
                    FROM gully g
                    JOIN value_state_type vst ON vst.id = g.state_type
                    JOIN exploitation e ON e.expl_id = g.expl_id
                    WHERE g.state = 1
                    AND vst.is_operative = TRUE
                    AND e.active = TRUE;
                $sql$, v_mapzone_field);

                EXECUTE format($sql$
                    CREATE OR REPLACE TEMPORARY VIEW v_temp_link_gully AS
                    SELECT
                        l.link_id,
                        g.arc_id,
                        l.feature_id,
                        l.feature_type,
                        l.expl_id,
                        l.%I,
                        l.the_geom
                    FROM link l
                    JOIN gully g ON l.feature_id = g.gully_id
                    JOIN value_state_type vst ON vst.id = l.state_type
                    JOIN exploitation e ON e.expl_id = l.expl_id
                    WHERE l.state = 1
                    AND vst.is_operative = TRUE
                    AND e.active = TRUE
                    AND l.feature_type = 'GULLY';
                $sql$, v_mapzone_field);

            END IF;

        END IF; 

        -- CHECKS - TODO
        -- =======================
        -- Check for arcs with missing node_1 or node_2
        /*SELECT string_agg(arc_id::text, ',') INTO v_arc_list FROM v_temp_arc
        WHERE arc.node_1 IS NULL OR arc.node_2 IS NULL;

        IF v_arc_list IS NOT NULL THEN
            EXECUTE 'SELECT gw_fct_getmessage($${"data":{"message":"4022", "function":"2706", "fid":"'||v_fid||'", "is_process":true,
            "parameters":{"v_arc_list":"'||v_arc_list||'"}}}$$)';
        END IF;
        */
        -- END CHECK

        v_return_message = 'The temporary tables/views have been created successfully';
    ELSIF v_action = 'DROP' THEN

        -- Drop temporary views
        DROP VIEW IF EXISTS v_temp_node;
        DROP VIEW IF EXISTS v_temp_arc;
        DROP VIEW IF EXISTS v_temp_connec;
        DROP VIEW IF EXISTS v_temp_gully;
        DROP VIEW IF EXISTS v_temp_link_connec;
        DROP VIEW IF EXISTS v_temp_link_gully;

        -- Drop temporary tables
        DROP TABLE IF EXISTS temp_pgr_mapzone;
        DROP TABLE IF EXISTS temp_pgr_old_mapzone;
        DROP TABLE IF EXISTS temp_pgr_graphconfig;
		DROP TABLE IF EXISTS temp_pgr_mapzone_graph;
		DROP TABLE IF EXISTS temp_pgr_dijkstra;
        DROP TABLE IF EXISTS temp_pgr_node;
        DROP TABLE IF EXISTS temp_pgr_arc;
        DROP TABLE IF EXISTS temp_pgr_connec;
        DROP TABLE IF EXISTS temp_pgr_gully;
        DROP TABLE IF EXISTS temp_audit_check_data;
        DROP TABLE IF EXISTS temp_pgr_connectedcomponents;
        DROP TABLE IF EXISTS temp_pgr_minsector_graph;
        DROP TABLE IF EXISTS temp_pgr_minsector;
        DROP TABLE IF EXISTS temp_pgr_minsector_mincut;
        DROP TABLE IF EXISTS temp_pgr_minsector_mincut_valve;
        DROP TABLE IF EXISTS temp_pgr_drivingdistance;
        DROP TABLE IF EXISTS temp_pgr_drivingdistance_initoverflowpath;
        DROP TABLE IF EXISTS temp_pgr_node_minsector;
        DROP TABLE IF EXISTS temp_pgr_arc_linegraph;
        DROP TABLE IF EXISTS temp_pgr_omunit;
        DROP TABLE IF EXISTS temp_pgr_macroomunit;

        DROP TABLE IF EXISTS temp_pgr_om_waterbalance_dma_graph;

        v_return_message = 'The temporary tables/views have been dropped successfully';
    END IF;

    RETURN jsonb_build_object(
        'status', 'Accepted',
        'message', jsonb_build_object(
            'level', 1,
            'text', v_return_message
        ),
        'version', v_version,
        'body', jsonb_build_object(
            'form', jsonb_build_object(),
            'data', jsonb_build_object()
        )
    );

 -- TODO: TO BE REMOVED
    EXCEPTION WHEN OTHERS THEN

    RETURN jsonb_build_object(
        'status', 'Failed',
        'message', jsonb_build_object(
            'level', 3,
            'text', 'An error occurred while managing temporary tables: ' || SQLERRM
        ),
        'version', v_version,
        'body', jsonb_build_object(
            'form', jsonb_build_object(),
            'data', jsonb_build_object()
        )
    );

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;

